<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACWing数学知识 总结与练习</title>
    <url>/acwing-0x30-tests/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/baiduPush.js"></script>

<h1 id="AcWing-220-最大公约数"><a href="#AcWing-220-最大公约数" class="headerlink" title="AcWing 220 最大公约数"></a>AcWing 220 最大公约数</h1><p>其实它让你求的就是</p>
<script type="math/tex; mode=display">
\sum_{x=1}^N\sum_{y=1}^N \phi (gcd(x,y))=gcd(x,y)-1</script><p>又由:</p>
<script type="math/tex; mode=display">
gcd(\frac{x}{gcd(x,y)},\frac{y}{gcd(x,y)})=1</script><p>可以将初始式除以质数，转化为:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{prime[i]\leq N}\sum_{j=1}^{prime[i]} \phi(j)</script><p>然后求1-N的$\phi(i)$的前缀和，按照上式求出答案即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10000005</span>;</span><br><span class="line"><span class="keyword">bool</span> iscomp[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[MAXN],phi[MAXN],p,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makePrime</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(iscomp,<span class="number">0</span>,<span class="keyword">sizeof</span>(iscomp));</span><br><span class="line">	iscomp[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!iscomp[i])&#123;</span><br><span class="line">			prime[++p]=i;</span><br><span class="line">			phi[i]=i<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i*prime[j]&gt;N) <span class="keyword">break</span>;</span><br><span class="line">			iscomp[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		phi[i]+=phi[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	makePrime(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">		ans+=<span class="number">2</span>*phi[N/prime[i]]<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-221-龙哥的问题"><a href="#AcWing-221-龙哥的问题" class="headerlink" title="AcWing 221 龙哥的问题"></a>AcWing 221 龙哥的问题</h1><p><del>我的问题</del></p>
<p>我们可以按照他的最大公约数进行分类，并求出每一组中数的数量:</p>
<blockquote>
<p>如果i与N的gcd为1，那么就是求小于等于N且与N互质的数的个数，显然是$\phi(N)$。</p>
<p>如果i与N的gcd为2，那么就是求gcd(i/2,N/2)为1的数量，显然是$\phi(N/2)$。</p>
<p>如果i与N的gcd为3，那么就是求gcd(i/3N/3)为1的数量，显然是$\phi(N/3)$。</p>
</blockquote>
<p>发现了点什么没有？</p>
<p>没错！我们就是要求$\phi(N/i) * i$的和！</p>
<p>所以答案可以用下式求出来：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N \phi(N/i)*i(N\%i==0)</script><p>所以求一下N的因数，然后$log(i)$时间求phi就好了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>ACWing 动态规划 总结与练习</title>
    <url>/acwing-0x50-tests/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/baiduPush.js"></script>

<h1 id="AcWing-312-乌龟棋"><a href="#AcWing-312-乌龟棋" class="headerlink" title="AcWing 312 乌龟棋"></a>AcWing 312 乌龟棋</h1><p>设 $ dp[i][j][k][l] $ 表示走的格数为1的卡用了i张，走的格数为2的卡为j张，走的格数为3的卡用了k张，走的格数为4的卡用了l张</p>
<p>那么很显然转移就是从每一张分别少一加上当前格子的分数取最大值。</p>
<p>初始值：$dp[0][0][0][0] = 0$，其余为负无穷。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000005</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XBY</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">nextchar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">100000</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nextchar getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(T&amp; num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> f,x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> sign;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">    f=<span class="number">1.0</span>/<span class="number">10</span>;</span><br><span class="line">    z=x=ch=num=sign=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch&lt;<span class="string">'0'</span>)||(ch&gt;<span class="string">'9'</span>)) &#123;sign|=(ch == <span class="string">'-'</span>);ch=nextchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> ((ch&gt;=<span class="string">'0'</span>)&amp;&amp;(ch&lt;=<span class="string">'9'</span>)) &#123;z=z*<span class="number">10</span>+(ch-<span class="string">'0'</span>);ch=nextchar();&#125;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'.'</span>)&#123;ch=nextchar();<span class="keyword">while</span> ((ch&gt;=<span class="string">'0'</span>)&amp;&amp;(ch&lt;=<span class="string">'9'</span>))&#123;x+=(ch^<span class="number">48</span>)*f;f/=<span class="number">10</span>;ch=nextchar();&#125;&#125;</span><br><span class="line">    num=sign?-z-x:z+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> T1&gt; <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(T&amp; num,T1&amp; num1)</span></span>&#123;input(num),input(num1);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(T&amp; num,T1&amp; num1,T2&amp; num2)</span></span>&#123;input(num),input(num1),input(num2);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt; <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(T&amp; num,T1&amp; num1,T2&amp; num2,T3&amp; num3)</span></span>&#123;input(num),input(num1),input(num2),input(num3);&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> score[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(" .in","r",stdin);</span></span><br><span class="line"><span class="comment">//  freopen(" .out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;score[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        cnt[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=score[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[<span class="number">1</span>];i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[<span class="number">2</span>];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cnt[<span class="number">3</span>];k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cnt[<span class="number">4</span>];l++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> dist=i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+score[dist]);</span><br><span class="line">                    <span class="keyword">if</span>(j!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+score[dist]);</span><br><span class="line">                    <span class="keyword">if</span>(k!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+score[dist]);</span><br><span class="line">                    <span class="keyword">if</span>(l!=<span class="number">0</span>) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+score[dist]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]][cnt[<span class="number">3</span>]][cnt[<span class="number">4</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-313-花店橱窗"><a href="#AcWing-313-花店橱窗" class="headerlink" title="AcWing 313 花店橱窗"></a>AcWing 313 花店橱窗</h1><p>设$dp[i][j]$为第i种花放在第j个花瓶的最大总美观度，$val[i][j]$为第i朵花放在第j个花瓶所带来的美观度，则:</p>
<script type="math/tex; mode=display">
dp[i][j]=(max_{k=0}^{j-1} dp[i-1][k] )+ val[i][j]</script><p>初始值：$dp[0][0]=0$，其余为负无穷。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prv[MAXN][MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[MAXN][MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-1e18</span>,ansp;</span><br><span class="line"><span class="keyword">int</span> p,pos[MAXN],r;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0xC0</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">//0xC0C0C0C0C0C0C0C0为乘2后不会爆long long的最小值</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;val[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i<span class="number">-1</span>][k]+val[i][j]&gt;dp[i][j])&#123;</span><br><span class="line">					prv[i][j]=k;</span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][k]+val[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==N)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans&lt;dp[i][j])&#123;</span><br><span class="line">					ans=dp[i][j];</span><br><span class="line">					ansp=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	r=N;</span><br><span class="line">	<span class="keyword">while</span>(r)&#123;</span><br><span class="line">		pos[++p]=ansp;</span><br><span class="line">		ansp=prv[r][ansp];</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&gt;=<span class="number">1</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d "</span>,pos[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-314-低买"><a href="#AcWing-314-低买" class="headerlink" title="AcWing 314 低买"></a>AcWing 314 低买</h1><p>这道题能一眼看出来是最长下降子序列，但是好像要记录方案数……</p>
<p>所以在折腾了半天以后，我发现了华点：$ N=5000 $。</p>
<p>所以说，没有必要$O(NlogN)$dp了。</p>
<p>那直接$O(N^2)$dp就可以:$dp[i]$表示以第i号元素为结尾的最长下降子序列的长度，</p>
<p>$cnt[i]$表示以第i号元素为结尾的最长下降子序列数量，我们可以轻松的得到$dp$的转移方程:</p>
<script type="math/tex; mode=display">
dp[i]=max_{j=1}^{i-1}(dp[j]+1)</script><p>而$cnt$的转移方程就有点意思了：</p>
<p>由于相同dp值而相同结尾的cnt会被记重，我们只需要在这种情况下置零就可以避免尴尬了：</p>
<script type="math/tex; mode=display">
cnt[i]=
\left\{
  \begin{array}{crl}
  0 & exist & j<i,dp[j]=dp[i]\&\&a[j]==a[i]\\
  \sum_{j=1}^{i-1} cnt[j]+1 & dp[i]=1,\\
  \sum_{j=1}^{i-1} cnt[j] & defalt\\
  \end{array}
\right.</script><p>初始值：$dp$全为1，$cnt$全为0。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>,ans1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		dp[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[i])&#123;</span><br><span class="line">				dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">				ans=max(ans,dp[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]==<span class="number">1</span>) cnt[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[i]&amp;&amp;dp[i]==dp[j]+<span class="number">1</span>) cnt[i]+=cnt[j];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==a[j]&amp;&amp;dp[i]==dp[j]) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="keyword">if</span>(dp[i]==ans) ans1+=cnt[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-315-旅行"><a href="#AcWing-315-旅行" class="headerlink" title="AcWing 315 旅行"></a>AcWing 315 旅行</h1><p>这道题目和上道题目长得很像，都是让你在原来的简单题目上增强，变成统计方案数的题目。</p>
<p>做这题我长记性了，先看了数据范围，发现：$1&lt;=N&lt;=80$，用$O(N^2)$的算法就可以。</p>
<p>设$dp[i][j]$为s串前i个字符和t串前j个字符组成的最长公共子序列的长度，则：</p>
<script type="math/tex; mode=display">
dp[i][j]=
\left\{
  \begin{array}{rl}
  max(dp[i-1][j],dp[i][j-1]), & s[i]!=t[j]\\
  dp[i-1][j-1]+1, & s[i]==t[j]
  \end{array}
\right.</script><p>但是好像输出方案和输出方案数没有解决啊……</p>
<p>我们有强大的工具：枚举。</p>
<p>设$preS[i][j]$代表s串前i个字符中最靠后的j字符的位置，</p>
<p>设$preT[i][j]$代表t串前i个字符中最靠后的j字符的位置，很明显有：</p>
<script type="math/tex; mode=display">
preS[i][j]=
\left\{
  \begin{array}{rl}
  preS[i-1][j], & s[i]!='a'+j\\
  i, & s[i]=='a'+j
  \end{array}
\right.</script><p>然后我们枚举LCS相同的字符是哪个，如果有找到$dp[i_1][j_1]+1=dp[i][j]$且$preS[i_1][k]=preT[j_1][k]$，就递归向下，继续寻找，最后排个序就好了。</p>
<p>所以这道题最后用vector+string最方便了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">85</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN],t[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> preS[MAXN][<span class="number">26</span>],preT[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> len,<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!len) vec.push_back(s);</span><br><span class="line">	<span class="keyword">if</span>(!n||!m||!len) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[preS[n][i]][preT[m][i]]==len) findPath(preS[n][i]<span class="number">-1</span>,preT[m][i]<span class="number">-1</span>,len<span class="number">-1</span>,((<span class="keyword">char</span>)(<span class="string">'a'</span>+i))+s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">	N=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	M=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'a'</span>+j) preS[i][j]=i;</span><br><span class="line">			<span class="keyword">else</span> preS[i][j]=preS[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t[i]==<span class="string">'a'</span>+j) preT[i][j]=i;</span><br><span class="line">			<span class="keyword">else</span> preT[i][j]=preT[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==t[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	findPath(N,M,dp[N][M],<span class="string">""</span>);</span><br><span class="line">	sort(vec.begin(),vec.end());</span><br><span class="line">	<span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++) <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-316-减操作"><a href="#AcWing-316-减操作" class="headerlink" title="AcWing 316 减操作"></a>AcWing 316 减操作</h1><p>这道题目很思维，首先在漫长的思考中我觉得有足够的时间应该能想到的：</p>
<p>如果这个数列称为a的话，这个数肯定可以被凑成如下形式：</p>
<script type="math/tex; mode=display">
X=a[1]-a[2] \pm a[3] \pm a[4] ... \pm a[N]</script><p>我先从两个角度来证明这件事：</p>
<p>1 你要凑的这个数一定能被凑出来，因为他没告诉你凑不出来怎么办；</p>
<p>2 a[1]肯定是要减其他数而没有办法被其他数减，所以a[1]是正的；</p>
<p>   而a[2]只会被a[1]减一次，而不会被减其他次数，于是a[2]是负的；</p>
<p>   而a[i]既可以通过调整减操作的顺序，来被减奇数次或偶数次，所以a[i]正负任意。</p>
<p>于是我们对这道题目进行了一个模型转化：</p>
<p><strong>将a中的一些数由正变负，使得a数组的和为X</strong></p>
<p>我们就可以由此得到一个dp方程：</p>
<p>设$dp[i][j]$表示前i个数和为j，第i个数的正负，则：</p>
<script type="math/tex; mode=display">
dp[i-1][j]!=0时：\\
dp[i][j+a[i]]=1\\
dp[i][j-a[i]]=-1</script><p>初始值：    $dp[1][a[1]+add]$为1,$dp[2][a[1]-a[2]+add]$为-1;其他全部为0</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> add=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXM*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sign[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],tmp,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	dp[<span class="number">1</span>][a[<span class="number">1</span>]+add]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>][a[<span class="number">1</span>]-a[<span class="number">2</span>]+add]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20001</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">				dp[i][a[i]+j]=<span class="number">1</span>;</span><br><span class="line">                dp[i][j-a[i]]=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    tmp=add+M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">    	sign[i]=dp[i][tmp];</span><br><span class="line">        <span class="keyword">if</span>(dp[i][tmp]==<span class="number">1</span>) tmp-=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][tmp]==<span class="number">-1</span>) tmp+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-cnt<span class="number">-1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++) <span class="keyword">if</span>(sign[i]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AcWing-320-能量项链"><a href="#AcWing-320-能量项链" class="headerlink" title="AcWing 320 能量项链"></a>AcWing 320 能量项链</h1><p>区间dp模板题，直接把数组原样复制一遍，然后再做区间dp就好了，在dp时顺便维护最大值。</p>
<p>设$dp[l][r]$表示合并l到r所获得的最大能量，则：</p>
<script type="math/tex; mode=display">
dp[l][r]=max_{mid=l}^{r-1}(dp[l][mid]+dp[mid+1][r]+e[l]*e[mid+1]*e[r]);</script><p>初始值：全为零。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,e[<span class="number">300</span>],s[<span class="number">300</span>][<span class="number">300</span>],maxn;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e[i]);</span><br><span class="line">        e[i+n]=e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;i-j&lt;n&amp;&amp;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;i;k++)</span><br><span class="line">            s[j][i]=max(s[j][i],s[j][k]+s[k+<span class="number">1</span>][i]+e[j]*e[k+<span class="number">1</span>]*e[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(s[j][i]&gt;maxn)maxn=s[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>图论总结</title>
    <url>/graphTotal/</url>
    <content><![CDATA[<p><script type="text/javascript" src="/js/baiduPush.js"></script><br>鉴于LXK他太菜了，学的东西都忘了，于是他写了这篇博客来记录自己都学了什么。</p>
<p>如果今年<del>NOIP</del>CSP-S考的很好，LXK会继续更新。</p>
<h1 id="图论基本知识"><a href="#图论基本知识" class="headerlink" title="图论基本知识"></a>图论基本知识</h1><p><strong>这里讲的都是图论里很基本很基本的知识，Dalao们可以跳过</strong></p>
<p>本章目录：</p>
<p><strong>1. 图的基本定义</strong></p>
<p><strong>2. 边的分类</strong></p>
<p><strong>3. 度</strong></p>
<p><strong>4. 图的分类</strong></p>
<a id="more"></a>
<h2 id="图的基本定义"><a href="#图的基本定义" class="headerlink" title="图的基本定义"></a>图的基本定义</h2><p>图是一个<strong>非空的</strong>由点集合边集合组成的集合。</p>
<img src="/graphTotal/%E4%B8%80%E4%B8%AA%E5%9B%BE.png" class title="一个图">
<p><del><strong>对的就是这个样子</strong></del></p>
<h2 id="边的分类"><a href="#边的分类" class="headerlink" title="边的分类"></a>边的分类</h2><p>边可以分成有向边和无向边两种。有向边是有方向的，他只允许单向通行。对于有向边，指向一个点的边是这个点的入边，从一个点出发的边称为这个点的出边。</p>
<p>有向边是允许双向通行的，通过简单的思考我们可以发现在处理无向边时可以将其拆成两条有向边处理。</p>
<p>有些边会与其他边重合，此时我们称其为重边。</p>
<p>有些边的起始点和终止点都是一个点，我们称这条边为自环。</p>
<h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>一个点的度是和这个点有关的边的数量。在有向图中，一个点的入度为这个边的入边的数量，一个点的出度为这个点出边的数量。自环算作一个入度和一个出度。（出发一次进入一次）</p>
<h2 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h2><p>图可以根据它所含的边的类别进行分类：</p>
<p>如果图中的边全部是有向边，则这张图是有向图。</p>
<p>如果图中的边全部是无向边，则这张图是无向图。</p>
<p>如果图中的边有权值，则这张图是带权图。</p>
<p>图也可以按照边的数量进行分类：</p>
<p>如果图中任意两个点都有边互相连接，则这张图是完全图。</p>
<p>如果图中边的数量接近完全图边的数量，则这张图为稠密图。</p>
<p>如果图中边的数量远小于完全图中边的数量，则这张图为稀疏图。</p>
<p>图也可以按照性质分类：</p>
<p>在一张无向图上，如果边的数量比点的数量少1，则这是一棵树。（注意：这棵树的树根为任意节点）</p>
<p>如果一个图没有环，这张图就是无环图。</p>
<h1 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h1><p>据LXK所知，图的储存方式有三种：邻接矩阵，邻接表，链式前向星。这个章节会介绍这三种存图方式的优缺点，并给吃相应的代码。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是LXK最早接触到的一种。它查找边的时间为O(1)，遍历所需时间为O(V^2),空间复杂度为O(V^2)，可以说是时间复杂度最低(遍历除外)空间复杂度最高的一种了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Edge[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//有向边</span></span><br><span class="line">    Edge[u][v]=w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的优点就在于判断是否存在一条特定的边的复杂度上：O(1)</p>
<p>他的缺点一坨一坨的，类似空间开销过大，遍历时间过长，都是他的大短板，复杂度皆为V^2，让人捉急。</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>它是为每一个节点开一个链表，其中储存的是它所能到达的节点。它的查找边最坏复杂度为O(M)，遍历复杂度为O(M)，空间复杂度为N*M</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; Edge[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//有向边</span></span><br><span class="line">    Edge[u].push_back(make_pair(v,w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其优点在于存储稀疏图时优秀的空间复杂度以及遍历的方便性；</p>
<p>其缺点在于其实现以及询问重边时的劣势。（邻接矩阵O(1)，邻接表O(M)）</p>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>它是邻接表不借助STL实现版，常数会比邻接表少一点（不开O2情况下），实现较为麻烦，但是他不会存在突然MLE的状况（会一开始就MLE）。其复杂度及优缺点同邻接表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;edge[MAXM*<span class="number">2</span>];<span class="comment">//无向图开两倍空间</span></span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//有向边</span></span><br><span class="line">    edge[++tot].nxt=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">    edge[tot].v=v;</span><br><span class="line">    edge[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edge[i].v])&#123;</span><br><span class="line">            dfs(edge[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图上求最短路"><a href="#图上求最短路" class="headerlink" title="图上求最短路"></a>图上求最短路</h1><p>在一张带权图上，题目可能会要求我们去求两点之间的最短路，在此给出一种暴力和三种算法进行解决。（暴力在别的题目里如果可以优化，所以要学一学）</p>
<p><strong>LXK在平常用链式前向星比较多，以下大部分代码遍历图的都是用链式前向星。</strong></p>
<p><strong>暴力会在  <a href="https://www.luogu.org/problem/P3371" target="_blank" rel="external nofollow noopener noreferrer" title="Luogu P3341">Luogu P3341 单源最短路（弱化版）</a> 测试，最短路正经算法 会在 <a href="https://www.luogu.org/problem/P4779" target="_blank" rel="external nofollow noopener noreferrer" title="Luogu P4779">Luogu P4779（标准版）</a> 测试。</strong></p>
<p>LXK已经蹦起来推荐Dijkstra堆优化版了，不过想要看看其他的可以自取。</p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>就是在遍历树时所用的深度优先搜索。</p>
<p>在此进行了一点小小的优化：只有 <code>dis[x]+edge[i].w&lt;dis[v]</code>时才会进入v点进行搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    dis[x]=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[x]+edge[i].w&lt;dis[edge[i].v])&#123;</span><br><span class="line">            dfs(edge[i].v,len+edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可在测试题目中获得40分。</p>
<p><em>注：这里的<code>dis[x]+edge[i].w&lt;dis[v]</code>就是最短路算法中的核心操作，在这里使用是因为dfs如果不用松弛会死循环。</em></p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>这个在走迷宫一类的题目上会非常有用，但是在平时求最短路会显得十分无力。因为他是在到达终点以后就立刻停止，而最短路是你不一定到了就是最短的，于是乎就挂掉了。</p>
<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>这是一种基于DP思想的求最短路方式。它能够在O(N^3)时间内求出任意两点之间的最短距离。不过如果要使用<em>Floyd</em>的话必须用邻接矩阵存图。</p>
<p><strong>Q: 既然这种办法基于DP，那么肯定会有转移方程呀！</strong></p>
<p>它确实有一个十分简洁的转移方程。设<em>dis i j</em>为ij两点的最短路，则转移方程为：</p>
<script type="math/tex; mode=display">
dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</script><p>其中k为一个中转点。</p>
<p>思想极其显然：i j两点最短距离就是i到k的最短距离加上k到j的最短距离。</p>
<p>那么代码就很好写出来了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[MAXN][MAXN],u,v,w;<span class="comment">//虽然最短路可能在int范围内，但是两个int加在一起就爆了</span></span><br><span class="line"><span class="keyword">int</span> N,M,S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;<span class="comment">//++i会比i++快一点</span></span><br><span class="line">        dis[i][i]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;++j)&#123;</span><br><span class="line">                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;N,&amp;M,&amp;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            dis[i][j]=<span class="number">2147483647</span>;<span class="comment">//最短路不会爆int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;<span class="comment">//++i会比i++快一点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dis[u][v]=min(dis[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,dis[S][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://www.luogu.org/problem/P3371" target="_blank" rel="external nofollow noopener noreferrer" title="Luogu P3341">Luogu P3341</a> 中得到了70分（因为只能开的下1000*1000的大小），在 <a href="https://www.luogu.org/problem/P4779" target="_blank" rel="external nofollow noopener noreferrer">Luogu P4779</a>中爆零（数据范围过大，N^2空间完全爆炸）</p>
<h2 id="Bellman-Ford-与-SPFA"><a href="#Bellman-Ford-与-SPFA" class="headerlink" title="Bellman-Ford 与 SPFA"></a>Bellman-Ford 与 SPFA</h2><p>这两个算法可以说是一个爸爸一个儿子，只不过儿子比爸爸强，不过也不怎么稳定。</p>
<p>这两者的时间复杂度都趋于O(NM)，不过SPFA<del>看脸</del>看数据，如果不卡SPFA基本上都可以用。</p>
<p>这两个算法有两个很强的能力：跑负权图和判断负环（边权之和小于0的环）</p>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>Bellman-Ford是SPFA优化前的版本。其核心在于将所有的边<strong>松弛</strong>N-1遍。</p>
<p>其对于负环的判定十分简单，就是看在第N轮时是否有能够再次松弛的边，有即此图存在负环。</p>
<p><del>然鹅LXK并不会证明这件事</del></p>
<p>所以代码就很好写啦：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellmanFord</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;<span class="comment">//松弛N遍</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=head[j];k;k=edge[k].nxt)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[u]+edge[k].w&lt;dis[edge[k].v])&#123;<span class="comment">//如果能够松弛</span></span><br><span class="line">                    flag=<span class="literal">true</span>;</span><br><span class="line">                    dis[edge[k].v]=dis[u]+edge[k].w;<span class="comment">//松弛</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==N&amp;&amp;flag) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有负环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;<span class="comment">//一个小小的优化：如果不能松弛了，就跳出去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：所谓松弛，就是在<code>dis[x]+edge[i].w&lt;dis[v]</code>时更新<code>dis[v]</code></em></p>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA是优化版的Bellman-Ford。其核心在于将对于每条边更新改为对于一个点连着的所有点进行更新，并且在不用更新时退出，并使用队列维护所用节点。但是时间复杂度很玄学，不建议使用。后果如<a href="https://www.luogu.org/problem/P4779" target="_blank" rel="external nofollow noopener noreferrer">Luogu P4779</a> 题面所说，请自行承担。</p>
<p><del>LXK：突然变严肃了喵喵喵???</del></p>
<p>SPFA判断负环的方式与Bellman-Ford类似：查看每一个节点入队次数，如果大于N则说明有负环存在。</p>
<p>代码很像BFS，但是<strong>不是BFS</strong>，请不要记混。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[MAXN];<span class="comment">//计次</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//查看当前节点是否在队列中。</span></span><br><span class="line"><span class="keyword">int</span> N,M,S;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q[MAXN+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;,l,r;<span class="comment">//记得初始化</span></span><br><span class="line">    l=r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        dis[i]=<span class="number">2147483647</span>;</span><br><span class="line">        cnt[i]=<span class="number">0</span>;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[S]=<span class="number">0</span>;</span><br><span class="line">    q[r]=S;</span><br><span class="line">    vis[S]=<span class="literal">true</span>;</span><br><span class="line">    ++r;</span><br><span class="line">    <span class="keyword">while</span>(r!=l)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[l];</span><br><span class="line">        vis[u]=<span class="literal">false</span>;</span><br><span class="line">        ++l;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;N+<span class="number">1</span>) l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;<span class="comment">//u如果在队列里就可以不管了</span></span><br><span class="line">            <span class="keyword">if</span>(dis[u]+edge[i].w&lt;dis[edge[i].v])&#123;<span class="comment">//这里即使v点已经在队列里了，也要进行松弛</span></span><br><span class="line">                dis[edge[i].v]=dis[u]+edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].v])&#123;<span class="comment">//v点不在队列里</span></span><br><span class="line">	                cnt[edge[i].v]++;<span class="comment">//计算次数</span></span><br><span class="line">	                vis[edge[i].v]=<span class="literal">true</span>;</span><br><span class="line">	                q[r]=edge[i].v;<span class="comment">//进队</span></span><br><span class="line">	                ++r;</span><br><span class="line">	                <span class="keyword">if</span>(r&gt;N+<span class="number">1</span>) r=<span class="number">0</span>;</span><br><span class="line">	                <span class="keyword">if</span>(cnt[edge[i].v]&gt;N) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断负环</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.org/problem/P3371" target="_blank" rel="external nofollow noopener noreferrer" title="Luogu P3341">Luogu P3341</a>满分通过，<a href="https://www.luogu.org/problem/P4779" target="_blank" rel="external nofollow noopener noreferrer">Luogu P4779</a> 32分TLE。</p>
<p><strong>是时候请出来Dijkstra了</strong></p>
<h2 id="Dijkstra与其堆优化"><a href="#Dijkstra与其堆优化" class="headerlink" title="Dijkstra与其堆优化"></a>Dijkstra与其堆优化</h2><p>Dijkstra堆优化在跑无负权图时有着很好的表现十分稳定(NlogN),但是一旦遇到负权图就做不出正解。但是他在一般状况下表现得都比SPFA要好一点。</p>
<h3 id="Dijkstra无优化"><a href="#Dijkstra无优化" class="headerlink" title="Dijkstra无优化"></a>Dijkstra无优化</h3><p>LXK：这都已经用不上了还看它干嘛而且只能跑正权图（小声bb）</p>
<p>我：这不就是为了<del>复习才写</del>了解原始方式并对其进行相应优化吗</p>
<p>Dijkstra是一种<del>比和珅还贪</del>贪心算法,他是遍历距离源点最近的还未被访问过的点,通过与之相连的出边贪心地更新剩下的点的答案。时间复杂度约为O(N^2)，当一个点连的边太多了的时候就会变d成O(NM)，这就是为什么有些算法要测“菊花图”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="comment">//  memset(dis,0x3f,sizeof(dis));//设成当前类型的最大值的二分之一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    	dis[i]=<span class="number">2147483647</span>;<span class="comment">//万恶的题面 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Min=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;Min)&#123;</span><br><span class="line">                Min=dis[i];</span><br><span class="line">                u=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Min==<span class="number">0x3f3f3f3f3f3f3f3f</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[u];j;j=edge[j].nxt)&#123;</span><br><span class="line">            dis[edge[j].v]=min(dis[edge[j].v],dis[u]+edge[j].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.org/problem/P3371" target="_blank" rel="external nofollow noopener noreferrer" title="Luogu P3341">Luogu P3341</a>满分通过，<a href="https://www.luogu.org/problem/P4779" target="_blank" rel="external nofollow noopener noreferrer">Luogu P4779</a> 0分TLE。</p>
<p>对的，你没有看错，一个N^2算法竟然AC了！C了！了！</p>
<p><del>这就是为什么说随机数据水的缘故了……</del></p>
<h3 id="Dijkstra堆优化"><a href="#Dijkstra堆优化" class="headerlink" title="Dijkstra堆优化"></a>Dijkstra堆优化</h3><p>我们发现它真正慢的地方在于找Min的时候，于是我们加了一个堆优化它，复杂度变为O((N+M)logN)。不过STL常数大，于是我选择使用优先队列。 <del>不还是STL吗</del></p>
<p>细心的人可能会发现我用了一点技巧偷了一点懒，如果觉得好的话可以借鉴一下。</p>
<p>后期会把手写堆的坑填上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraHeap</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[S]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(-dis[S],S));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+edge[i].w&lt;dis[edge[i].v])&#123;</span><br><span class="line">                dis[edge[i].v]=dis[u]+edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[edge[i].v])&#123;</span><br><span class="line">                    q.push(make_pair(-dis[edge[i].v],edge[i].v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两题全部AC。<del>LXK：终于结束了</del></p>
<p>其实还有很多其他玄学优化<del>不过我不会</del>，以后填坑吧。</p>
<h1 id="图上求最小生成树"><a href="#图上求最小生成树" class="headerlink" title="图上求最小生成树"></a>图上求最小生成树</h1><p>MST（最小生成树）永远是一种很迷的东西，因为你永远不知道它什么时候能用上……</p>
<p>LXK：不过好像前面没有说最小生成树的定义啊…….</p>
<p><strong>最小生成树就是能够将所有点相互连通的边权值和最小的一棵树。</strong></p>
<p>总之，如果你要求最小生成树，目前有三种种解法可以用，这里只介绍两种<del>（当然如果您很厉害可以尝试自己口胡新算法）</del></p>
<p>一种是Kruskal，另一种是Prim。他们二者区别在于Prim在稠密图上跑的更快，Kruskal跑稀疏图跑的更快。</p>
<p>具体复杂度的话，<strong>Kruskal是O(MlogM),优化后Prim是(NlogN)</strong>。</p>
<p>代码会给出完整版，因为部分版和完整版长度已经差不多了。</p>
<p>测试题目为<a href="https://www.luogu.org/problem/P3366" target="_blank" rel="external nofollow noopener noreferrer">Luogu P3366 最小生成树</a> ,请自行查看题面。</p>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p>这是平常最常用的一种办法，它是将所有边按照边权从小到大排序，然后依次从小到大选。如果这条边和之前的边形成了环就跳过，直到选的边数比点数少一为止。</p>
<p>目前复杂度看起来是O（N^2+M）的,因为判断两个点是否在环中需要跑一遍才能知道。这个时候并查集就可以用了，它可以接近O(1)的时间查看两个点是否在同一集合中。于是就优化成了O(MlogM)，即将边排序的复杂度。</p>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">200005</span>;</span><br><span class="line"><span class="comment">//Union-Find Set 并查集</span></span><br><span class="line"><span class="keyword">int</span> father[MAXN],rk[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initUnion</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;<span class="comment">//初始化并查集</span></span><br><span class="line">	<span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		father[i]=i;<span class="comment">//将父亲设成自己</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//找自己并查集的老大</span></span><br><span class="line">	<span class="keyword">if</span>(father[x]!=x) father[x]=find(father[x]);<span class="comment">//路径压缩</span></span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> des,<span class="keyword">int</span> src)</span></span>&#123;<span class="comment">//将des和src所在的并查集合并</span></span><br><span class="line">	<span class="keyword">int</span> fSrc=find(src);</span><br><span class="line">	<span class="keyword">int</span> fDes=find(des);</span><br><span class="line">	<span class="keyword">if</span>(fSrc==fDes) <span class="keyword">return</span>;<span class="comment">//已经在一个集合里了，不用合并</span></span><br><span class="line">	<span class="keyword">if</span>(rk[fSrc]&gt;rk[fDes]) swap(fSrc,fDes);<span class="comment">//按秩合并</span></span><br><span class="line">	<span class="keyword">if</span>(rk[fSrc]==rk[fDes]) rk[fDes]++;</span><br><span class="line">	father[fSrc]=fDes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sameUnion</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> find(x)==find(y);<span class="comment">//老大是不是一个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Graph 存图</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里存图并没有使用前向星，而是直接存。</span></span><br><span class="line"><span class="comment">因为Kruskal需要对边排序，而前向星不支持排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge&amp; edge1)<span class="keyword">const</span>&#123;<span class="comment">//重载了结构体的运算符，可以直接sort</span></span><br><span class="line">		<span class="keyword">return</span> w&lt;edge1.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++tot].u=u;</span><br><span class="line">	edge[tot].v=v;</span><br><span class="line">	edge[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="keyword">int</span> ansNum[MAXM],cnt;<span class="comment">//本来是用来记录解集的，但是发现不需要。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;<span class="comment">//最小生成树边权之和</span></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sum=cnt=<span class="number">0</span>;</span><br><span class="line">	initUnion(N);<span class="comment">//初始化并查集</span></span><br><span class="line">	sort(edge+<span class="number">1</span>,edge+<span class="number">1</span>+tot);<span class="comment">//将边排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M&amp;&amp;cnt&lt;N<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sameUnion(edge[i].u,edge[i].v)) <span class="keyword">continue</span>;</span><br><span class="line">		ansNum[++cnt]=i;</span><br><span class="line">		sum+=edge[i].w;</span><br><span class="line">		merge(edge[i].u,edge[i].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==N<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		addEdge(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(kruskal()) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"orz\n"</span>);<span class="comment">//不存在输出orz</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以轻松拿下满分。</p>
<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>Prim算法的核心也是贪心，不过贪得不一样。Prim是从一个结点开始，尽量寻找与之连接的边权最小的边，并确保其另一端的点不会和已经加入生成树的点形成环。</p>
<p>简单来说就是能选多小选多小。</p>
<p>但是在找边权最小的值时Prim会对于每一个节点都扫一次，于是我们请出来了Dijkstra的帮手：堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="comment">//Graph</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;edge[<span class="number">2</span>*MAXM];</span><br><span class="line"><span class="keyword">int</span> tot,head[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++tot].nxt=head[u];</span><br><span class="line">	edge[tot].v=v;</span><br><span class="line">	edge[tot].w=w;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Prim</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//有没有访问过这个点 </span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum,dis[MAXN];<span class="comment">//dis[i]表示i与当前所在点目前的最小距离 </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	q.push(make_pair(-dis[<span class="number">1</span>],<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()&amp;&amp;cnt&lt;N)&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> d=-q.top().first;</span><br><span class="line">		<span class="keyword">int</span> u=q.top().second;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">		sum+=d;</span><br><span class="line">		vis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=edge[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">if</span>(edge[i].w&lt;dis[edge[i].v])&#123;</span><br><span class="line">				dis[edge[i].v]=edge[i].w;</span><br><span class="line">				q.push(make_pair(-dis[edge[i].v],edge[i].v));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		addEdge(u,v,w);</span><br><span class="line">		addEdge(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(prim()) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"orz\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然是轻轻松松AC。</p>
<h1 id="二分图问题"><a href="#二分图问题" class="headerlink" title="二分图问题"></a>二分图问题</h1><h2 id="二分图的定义与判断"><a href="#二分图的定义与判断" class="headerlink" title="二分图的定义与判断"></a>二分图的定义与判断</h2><p>好像讲了这么多，连二分图的影子都没看见过，只见过最小生成树这么一个特殊的图模型。</p>
<p>是时候讲一讲二分图到底是什么了。</p>
<p>如果一个图的点可以被分成两个集合，使得集合内部的点都没有边相连，那么这就是一张二分图。</p>
<p>类似下面两个，都是：</p>
<img src="/graphTotal/%E4%BA%8C%E5%88%86%E5%9B%BE.png" class title="二分图">
<p>那么如何判断一个图是否是二分图，或者说，如何判断一个图是否违反了二分图的定义呢？</p>
<p>经过一些找规律，我们发现：如果将相邻的点染上不同的颜色，且只能用两种颜色染，那么一个点一定只会被染同一种颜色。</p>
<p>所以我们只要从一个点开始，对其进行黑白染色，如果染色失败则证明本图不是二分图，若成功则证明本图是二分图。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
</search>
